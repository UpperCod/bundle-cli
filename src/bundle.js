import path from "path";
import glob from "fast-glob";
import rollup from "rollup";
import yaml from "js-yaml";
import marked from "marked";
import Mustache from "mustache";

import { readHtml } from "./read-html";
import { readCss } from "./read-css";
import { rollupPlugins } from "./rollup/config-plugins";
import { createServer } from "./server";

import {
  asyncFs,
  readFile,
  writeFile,
  copyFile,
  asyncGroup,
  getRelativePath,
  getRelativeDeep,
  isMd,
  isJs,
  isCss,
  isHtml,
  isFixLink,
  isNotFixLink,
  streamLog,
  getPackage,
  createAwait
} from "./utils";

import { watch } from "./watch";

export default async function createBundle(options) {
  options = await formatOptions(options);

  let files = await glob(options.src);

  // groups all manipulated files, prevents files
  // that have not been modified from being regenerated
  const mapFiles = new Map();

  // define if a file has already been manipulated
  const isReady = file => mapFiles.has(file);

  // !isReady
  const isNotReady = file => !isReady(file);

  // define if a file is of type template
  const isTemplate = file => options.template == file;

  // !isTempalte
  const isNotTemplate = file => !isTemplate(file);

  // delete the file, for new manipulation or
  // regeneration without the given file
  const deleteFile = file => {
    mapFiles.delete(file);
    return file;
  };

  // add a file to the registry and prevent a manipulation
  // job on it if it is verified with isReady
  const takeFile = file => {
    mapFiles.set(file, {
      imported: []
    });
    return file;
  };

  // cache stat generated by adding a file
  // This is used by searches in exportable files with only isHtml type...
  const cacheStat = new Map();

  // get the name of the file at the destination
  const getLink = file => {
    let { name, ext } = path.parse(file);
    return isFixLink(ext)
      ? name + (isJs(ext) ? ".js" : isMd(ext) ? ".html" : ext)
      : "file-" +
          file.split("").reduce((out, i) => (out + i.charCodeAt(0)) | 8, 4) +
          ext;
  };
  // get the final destination name
  const getDest = (file, folder = "") => path.join(options.dest, folder, file);

  // returns folder retracements based on relative path depth

  // promise to be resolved if watch mode has been enabled
  // allows to wait for the watch to complete to add a
  // new file to the queue, for a new regeneration
  const awaitWatch = createAwait();

  // date of last build
  let lastTime = new Date();
  // group the watchers to clean between each build
  let watchers = [];

  // store the server, eg: server.reload()
  let server;

  let currentRollupCache;

  if (options.server) {
    server = await createServer({
      dest: options.dest,
      watch: options.watch,
      port: options.port
    });
  }

  /**
   * regenerate the build
   * @param {string[]} files
   * @param {boolean} forceJs
   * @returns {Promise<void>}
   */
  async function readFiles(files, forceJs) {
    // normalize to avoid duplicates
    files = files.map(path.normalize);
    // check if one of the files is a template
    await asyncGroup(
      files
        .filter(isTemplate)
        .map(takeFile)
        .map(async file => {
          const template = mapFiles.get(file);
          const [code, meta] = getMetaFile(await readFile(file));

          template.meta = meta;
          template.code = code;

          // before each file regeneration, the associates are restarted,
          // in this case those that comply with isHtml
          [...mapFiles]
            .map(([file]) => file)
            .filter(isHtml)
            .filter(isNotTemplate)
            .map(deleteFile)
            .forEach(file => {
              if (!files.includes(file)) files.push(file);
            });
        })
    );

    // ignore template files
    files = files.filter(isNotTemplate);

    // the html are of high hierarchy, since through them the
    // exportable ones are identified to work for the inferior porcesos
    let groupHtml = files
      .filter(isHtml)
      .filter(isNotReady)
      .map(takeFile)
      .map(async file => {
        const { dir } = path.parse(file);
        let [code, meta] = getMetaFile(await readFile(file));
        const relativeDeep = getRelativeDeep(meta.folder);
        const link = getLink(file);
        const dest = getDest(link, meta.folder);
        const page = { ...meta, file, dest, link };
        if (isMd(file)) {
          code = marked(code);
        }

        const nextCode = await readHtml({
          code,
          useFragment: options.template ? true : false,
          async addFile(childFile) {
            let findFile = path.join(dir, childFile);
            if (!cacheStat.has(findFile)) {
              let type = "local";
              try {
                await asyncFs.stat(findFile);
              } catch (e) {
                try {
                  // try to resolve the dependency from node_modules
                  findFile = require.resolve(childFile);
                  type = "external";
                } catch (e) {
                  type = "global";
                }
              }

              cacheStat.set(findFile, { type, file: findFile });

              if (options.watch && type == "local") {
                awaitWatch.promise.then(({ addFile }) => addFile(findFile));
              }
            }

            let state = cacheStat.get(findFile);

            if (state.type == "global") return childFile;

            if (!files.includes(state.file)) {
              files.push(state.file);
            }

            if (!mapFiles.get(file).imported.includes(state.file)) {
              mapFiles.get(file).imported.push(state.file);
            }

            return relativeDeep + getLink(state.file);
          }
        });

        // save the state of the page
        // to be used by getPages
        mapFiles.get(file).page = page;

        return {
          code: nextCode,
          page
        };
      });

    groupHtml = await asyncGroup(groupHtml);

    // write the html files, the goal of this being done separately,
    // is to group the pages before writing to metadata
    await asyncGroup(
      groupHtml.map(({ code, page }) => {
        let template;
        if (options.template) {
          template = mapFiles.get(options.template);
        }

        if (template) {
          code = Mustache.render(
            page.template === false ? code : template.code,
            {
              page,
              theme: template.meta,
              pages: getPages(
                page,
                // access all pages
                [...mapFiles]
                  .filter(([file]) => !isTemplate(file) && isHtml(file))
                  .map(([, { page }]) => page)
              )
            },
            {
              content: code
            }
          );
        }

        writeFile(page.dest, code);
      })
    );
    // parallel task block
    await asyncGroup([
      asyncGroup(
        files
          .filter(isCss)
          .filter(isNotReady)
          .map(takeFile)
          .map(async file => {
            const code = await readFile(file);
            const nextCode = await readCss({
              file,
              code,
              minify: options.minify,
              browsers: options.browsers,
              addWatchFile(childFile) {
                if (options.watch) {
                  awaitWatch.promise.then(({ addFile }) =>
                    addFile(childFile, file)
                  );
                }
              }
            });
            return writeFile(getDest(getLink(file)), nextCode);
          })
      ),
      asyncGroup(
        files
          .filter(isNotFixLink)
          .filter(isNotReady)
          .map(takeFile)
          .map(async file => copyFile(file, getDest(getLink(file))))
      )
    ]);

    // Rollup only restarts if a new js has been added from external sources
    if (
      forceJs ||
      files
        .filter(isJs)
        .filter(isNotReady)
        .map(takeFile).length
    ) {
      watchers = watchers.filter(watcher => {
        watcher.close();
      });

      const input = {
        input: [...mapFiles].map(([file]) => file).filter(isJs),
        onwarn: streamLog,
        external: options.external,
        plugins: rollupPlugins(options),
        cache: currentRollupCache
      };

      const output = {
        dir: options.dest,
        format: "es",
        sourcemap: options.sourcemap,
        chunkFileNames: "chunks/[hash].js"
      };

      const bundle = await rollup.rollup(input);

      currentRollupCache = bundle.cache;

      if (options.watch) {
        const watcher = rollup.watch({
          ...input,
          output,
          watch: { exclude: "node_modules/**" }
        });

        watcher.on("event", async event => {
          switch (event.code) {
            case "START":
              lastTime = new Date();
              break;
            case "END":
              streamLog(`bundle: ${new Date() - lastTime}ms`);
              server && server.reload();
              break;
            case "ERROR":
              streamLog(event.error);
              break;
          }
        });

        watchers.push(watcher);
      }

      await bundle.write(output);
    } else {
      streamLog(`bundle: ${new Date() - lastTime}ms`);
      server && server.reload();
    }
  }
  try {
    await readFiles(files);

    if (options.watch) {
      const mapSubWatch = new Map();
      const isRootWatch = file =>
        mapSubWatch.has(file) ? !mapSubWatch.get(file).length : true;

      const watcher = watch(options.src, group => {
        let files = [];
        let forceJs;

        if (group.add) {
          let groupFiles = group.add
            .filter(isRootWatch)
            .filter(isFixLink)
            .filter(isNotReady);
          files = [...files, ...groupFiles];
        }
        if (group.change) {
          let groupChange = group.change;
          group.change
            .filter(file => mapSubWatch.has(file))
            .map(file => mapSubWatch.get(file))
            .reduce(
              (groupParent, groupChild) => groupParent.concat(groupChild),
              []
            )
            .forEach(file => {
              if (!groupChange.includes(file)) groupChange.push(file);
            });

          let groupFiles = groupChange
            .filter(file => isRootWatch(file) || isReady(file))
            .filter(isFixLink)
            .filter(file => !isJs(file))
            .map(deleteFile);

          files = [...files, ...groupFiles];
        }
        if (group.unlink) {
          if (
            group.unlink
              .filter(isJs)
              .filter(isReady)
              .map(deleteFile).length
          ) {
            forceJs = true;
          }
        }
        if (files.length || forceJs) {
          lastTime = new Date();
          readFiles(files, forceJs);
        }
      });
      awaitWatch.resolve({
        addFile(file, parentFile) {
          if (!mapSubWatch.has(file)) {
            mapSubWatch.set(file, []);
            watcher.add(file);
          }
          if (parentFile && !mapSubWatch.get(file).includes(parentFile)) {
            mapSubWatch.get(file).push(parentFile);
          }
        }
      });
    }
  } catch (e) {
    console.log(e);
  }
}

async function formatOptions({ src = [], config, external, ...ignore }) {
  const pkg = await getPackage();

  src = Array.isArray(src) ? src : src.split(/ *; */g);

  if (external) {
    external = Array.isArray(external)
      ? external
      : [true, "true"].includes(external)
      ? Object.keys(pkg.dependencies)
      : external.split(/ *, */);
  }

  external = [...(external || []), ...Object.keys(pkg.peerDependencies)];

  let options = {
    src,
    external,
    babel: pkg.babel,
    ...ignore,
    ...pkg[config]
  };

  if (options.template) {
    options.src.unshift((options.template = path.normalize(options.template)));
  }

  // normalize routes for fast-glob
  options.src = options.src.map(glob => glob.replace(/\\/g, "/"));

  return options;
}

export function getMetaFile(code) {
  let meta = {};
  code = code.replace(/---\s([.\s\S]*)\s---\s/, (all, content, index) => {
    if (!index) {
      meta = yaml.safeLoad(content);
      return "";
    }
    return all;
  });
  return [code, meta];
}
/**
 * generates a map of relative files to be used as a nav
 * @param {Page} page
 * @param {Page[]} filesHtml
 * @returns {[]}
 */
function getPages(page, filesHtml) {
  let link = path.join("./", page.folder || "", page.link);
  let file = page.file;
  let pages = filesHtml.map(page => ({
    ...page,
    // pages are regenerated by each page since each one can exist in a different directory
    link: getRelativePath(link, path.join("./", page.folder || "", page.link))
  }));

  // Create an indexable map, these are grouped by group
  return [
    ...pages.reduce((groups, page) => {
      [].concat(page.group || "").forEach(group => {
        if (!groups.has(group)) {
          groups.set(group, []);
        }
        // Prevent the link from cloning
        let list = groups.get(group);
        if (!list.some(({ link }) => link == page.link)) {
          list.push({ ...page, active: file == page.file });
        }
      });
      return groups;
    }, new Map())
  ]
    .map(([group, items]) => ({
      group,
      items: items.sort((a, b) => (a.title > b.title ? 1 : -1))
    }))
    .sort((a, b) => (a.group > b.group ? 1 : -1));
}

/**
 * @typedef {{folder?:string,link:string,title?:string}} Page
 */
